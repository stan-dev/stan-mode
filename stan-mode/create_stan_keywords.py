import json
import re
import sys
import os.path

_TEMPLATE = """;;; {el_file} --- Variables used by `stan-mode' -*- lexical-binding: t; -*-

;; Copyright (C) 2012, 2013, 2014, 2015, 2016  Jeffrey Arnold, Daniel Lee
;;               2019 Kazuki Yoshida

;; Author: Jeffrey Arnold <jeffrey.arnold@gmail.com>,
;;         Daniel Lee <bearlee@alum.mit.edu>,
;;         Kazuki Yoshida <kazukiyoshida@mail.harvard.edu>
;; Maintainer: Kazuki Yoshida <kazukiyoshida@mail.harvard.edu>
;; URL: http://github.com/stan-dev/stan-mode/stan-mode
;; Keywords: languages,c
;; Version: 9.2.0
;; Created: 2012-08-18
;; Package-Requires: ((emacs "24.3"))

;; This file is not part of GNU Emacs.

;;; Commentary:

;; DO NOT EDIT! file auto generated by {py_file}

;;; Code:

(defconst stan-keywords--language-version "{version}"
  "Stan modeling language version supported by `stan-mode'.")

(defconst stan-keywords--types-list
  {types}
  "List of data types in Stan.

   This includes both variable declariations and function return types.")

(defconst stan-keywords--function-return-types-list
  {return_types}
  "List of return types of Stan functions.")

(defconst stan-keywords--blocks-list
  {blocks}
  "List of the names of blocks in Stan.")

(defconst stan-keywords--range-constraints-list
  {range_constraints}
  "List of range constraint keywords in Stan.")

(defconst stan-keywords--keywords-list
  {keywords}
  "List of keywords in Stan.")

(defconst stan-keywords--functions-list
  {functions}
  "List of functions in Stan.")

(defconst stan-keywords--distribution-list
  {distributions}
  "List of distributions in Stan.")

(defconst stan-keywords--reserved-list
  {reserved}
  "List of reserved keywords in Stan.")

(defconst stan-keywords--deprecated-function-list
  {deprecated}
  "List of deprecated functions in Stan.")

(provide 'stan-keywords)

;;; {el_file} ends here

"""

DISTR_PARTS = ('Continuous Distributions', 'Discrete Distributions')

def sexp(x):
    return "'(\n" + '\n'.join('    "%s"' % atom for atom in x) + "\n    )"

def read_json(filename):
    with open(filename, "r") as f:
        data = json.load(f)

    keywords = set()
    for k in ('control', 'other', 'functions'):
        for x in data['keywords'][k]:
            keywords.add(x)
    keywords = sorted(list(keywords))
    # Names for ~ distribution() notation
    distributions = sorted([v['sampling'] for k, v in data['functions'].items() if v['sampling']])
    deprecated = set()
    for x in data['deprecated']:
        deprecated.add(x)
    # Generate a deprecated equivalent for each *_lpdf/lpmf/lcdf/lccdf
    funnames = sorted(k for k, v in data['functions'].items())
    # https://mc-stan.org/docs/2_19/reference-manual/log-density-and-mass-functions.html
    # https://mc-stan.org/docs/2_19/reference-manual/cdf-log-and-ccdf-log-cumulative-distribution-functions.html
    for funname in funnames:
        if bool(re.match(r'.*_lpdf$', funname)):
            deprecated_funname = re.sub(r'_lpdf$', '_log', funname)
            if deprecated_funname not in distributions:
                # Need to check because some like poisson_log have been redefined.
                deprecated.add(deprecated_funname)
        elif bool(re.match(r'.*_lpmf$', funname)):
            deprecated_funname = re.sub(r'_lpmf$', '_log', funname)
            if deprecated_funname not in distributions:
                # Need to check because some like poisson_log have been redefined.
                deprecated.add(deprecated_funname)
        elif bool(re.match(r'.*_lcdf$', funname)):
            deprecated_funname = re.sub(r'_lcdf$', '_cdf_log', funname)
            deprecated.add(deprecated_funname)
        elif bool(re.match(r'.*_lccdf$', funname)):
            deprecated_funname = re.sub(r'_lccdf$', '_ccdf_log', funname)
            deprecated.add(deprecated_funname)
    deprecated = sorted(list(deprecated))
    reserved = set()
    for k in data['reserved']:
        for x in data['reserved'][k]:
            if x not in keywords:
                 reserved.add(x)
    reserved = sorted(list(reserved))
    types = sorted(data['types']['variable'])
    return_types = sorted(data['types']['return'])
    blocks = sorted(data['blocks'])
    range_constraints = sorted(data['keywords']['range_constraints'])
    functions = sorted(k for k, v in data['functions'].items()
                       if not (v['operator'] or v['keyword'] or v['deprecated']
                               or (k in deprecated)))
    deprecated = sorted(list(deprecated))

    return {
        'blocks' : sexp(sorted(blocks)),
        'range_constraints' : sexp(sorted(range_constraints)),
        'distributions' : sexp(sorted(distributions)),
        'functions' : sexp(sorted(functions)),
        'keywords' : sexp(sorted(keywords)),
        'reserved' : sexp(sorted(reserved)),
        'types' : sexp(sorted(types)),
        'return_types' : sexp(sorted(return_types)),
        'version' : data['version'],
        'deprecated' : sexp(sorted(deprecated)),
        'py_file' : os.path.split(__file__)[1]
    }

def create_code(data, dst):
    data.update({'el_file' : os.path.split(dst)[1]})
    with open(dst, 'w') as f:
        f.write(_TEMPLATE.format(**data))

if __name__ == '__main__':
    create_code(read_json(sys.argv[1]), sys.argv[2])
